var u=Object.defineProperty;var d=(s,t,n)=>t in s?u(s,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[t]=n;var a=(s,t,n)=>d(s,typeof t!="symbol"?t+"":t,n);import{i}from"./DSoDdw3M.js";class r{constructor(t){this.path=t}static async load(t){const n=await i("plugin:sql|load",{db:t});return new r(n)}static get(t){return new r(t)}async execute(t,n){const[e,c]=await i("plugin:sql|execute",{db:this.path,query:t,values:n??[]});return{lastInsertId:c,rowsAffected:e}}async select(t,n){return await i("plugin:sql|select",{db:this.path,query:t,values:n??[]})}async close(t){return await i("plugin:sql|close",{db:t})}}class h{constructor(){a(this,"id","tauri");a(this,"connections",new Map)}isAvailable(){return typeof window<"u"&&"__TAURI__"in window}async connect(t){if(!t.connectionString)throw new Error("Connection string is required for Tauri provider");const n=`tauri-${t.type}-${Date.now()}`,e=await r.load(t.connectionString);return this.connections.set(n,e),n}async disconnect(t){const n=this.connections.get(t);n&&(await n.close(),this.connections.delete(t))}async select(t,n){const e=this.connections.get(t);if(!e)throw new Error(`Connection not found: ${t}`);return e.select(n)}async execute(t,n,e){const c=this.connections.get(t);if(!c)throw new Error(`Connection not found: ${t}`);const o=await c.execute(n,e);return{rowsAffected:(o==null?void 0:o.rowsAffected)??0,lastInsertId:o==null?void 0:o.lastInsertId}}async test(t){if(!t.connectionString)throw new Error("Connection string is required for Tauri provider");await(await r.load(t.connectionString)).close()}getDatabase(t){return this.connections.get(t)}}export{h as TauriDatabaseProvider};
